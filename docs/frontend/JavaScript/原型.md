## 原型和继承

### 前言

#### 函数与对象的关系

- 函数是对象的一种

```javascript
var fn = function Fn(){
  this.name = '测试';
  this.year = 1998;
}
console.log(fn instanceof Object) //true
```

- 对象都是通过函数创建的

```javascript
//这样创建对象是js的语法糖
var obj = {a:10,b:20,c:30}
//本质上是下面这样创建的
//var obj = new Object();
//obj.a = 10; obj.b = 20; obj.c = 30; 
```

### 基本概念

#### **原型--------prototype对象**

每个函数都有一个属性prototype,默认prototype对象只有一个constructor属性，指向函数本身。

![172121182841896](./assets/172121182841896.png)

我们也可以在prototype对象中增加自己定义的属性

```javascript
function Fn(){
  Fn.prototype.name = '阿飞';
  Fn.prototype.getName = function(){
    return this.name;
  }
}
```

**每个对象都有一个隐藏属性`__proto__`指向创建了这个对象的原型对象prototype**

```javascript
var fn = new Fn();
console.log(fn.__proto__ == Fn.prototype);  //true
```

**Object的原型对象的`__proto__` 指向null**

```javascript
console.log(Object.prototype.__proto__); //null
```

**Function的原型对象的`__proto__` 指向自身**

Function也是一个函数，函数也是一种对象，也有`__proto__` 属性，Function因为是函数，所以是被自身创建的，所以它的`__proto__`指向了自身的prototype

![20180613163024859](./assets/20180613163024859-1977239.png)

#### instanceof判断规则

判断`A instanceof B`，A一般是一个对象，B一般是一个函数，沿着A的`__proto__`这条线找，同时沿着B的prototype这条线找，如果两条线能找到同一个对象引用，则返回true.如果到终点还没找到同一个对象引用，则返回false

### 继承

#### 原型链

```javascript
function Foo(){}

var f1 = new Foo();
f1.a = 100;
Foo.prototype.a = 10;
Foo.prototype.b = 200;
console.log(f1.a);//100
console.log(f1.b);//200

var f2 = new Foo();
console.log(f2.a);//10
```

**当访问一个对象的属性时，会先在基本属性中查找，如果没有，再沿着`__proto__`这条链向上找，这就是原型链**

当我们要区分一个属性是对象本身的还是从原型上找到的，使用Object.prototype原型对象上的**hasOwnProperty**方法来判断

```javascript
function Foo(){}

var f1 = new Foo();
f1.a = 100;
Foo.prototype.a = 10;
Foo.prototype.b = 200;
for(let item in f1){
  if(f1.hasOwnProperty(item)){
    console.log(item); //a
  }
}
```



#### 原型链继承

使用原型链实现SubType继承SuperType,通过创建SuperType的实例并将其赋值给SubType的原型对象prototype，这个赋值重写了SubType最初的原型对象，意味着SuperType实例可以访问的所有属性和方法也会存在于SubType的原型对象上。

```javascript
function SuperType(){
  this.property = true;
}
SuperType.prototype.getSuperValue = function(){
  return this.property;
}
function SubType(){
  this.subproperty = false;
}
//SubType继承SuperType
SubType.prototype = new SuperType();
SubType.prototype.getSubValue = function(){
  return this.subproperty;
}
let childType = new SubType();
console.log(childType.getSuperValue());//true
```

- 原型链的问题

1.在原型中包含引用值的时候，会在所有实例间共享，下面这个例子揭示了这个问题

```javascript
function SuperType(){
  this.colors = ['red','blue','green'];
}
function SubType(){}
SubType.prototype = new SuperType();
let instance1 = new SubType();
instance1.colors.push("black");
console.log(instance1.colors);//['red','blue','green','black']
let instance2 = new SubType();
console.log(instance2.colors);//['red','blue','green','black']
```

2.子类型在实例化时不能给父类型的构造函数传参



#### 盗用构造函数（对象伪装、经典继承）

在子类构造函数中调用父类构造函数，因为函数是在特定上下文中执行代码的简单对象，所以可以使用apply()和call()方法以新创建的对象为上下文执行构造函数。

```javascript
function SuperType(){
  this.colors = ['red','blue','green'];
}
function SubType(){
  //继承SuperType
  SuperType.call(this);
}
let instance1 = new SubType();
instance1.colors.push('black');
console.log(instance1.colors);//['red','blue','green','black']
let instance2 = new SubType();
console.log(instance2.colors);//['red','blue','green']
```

**传递参数**

盗用构造函数的一个有点是可以在子类构造函数中向父类构造函数传参。

```javascript
function SuperType(name){
  this.name = name;
}
function SubType(){
  //继承SuperType并传参
  SuperType.call(this,'nihao');
  //示例属性
  this.age = 29;
}

let instance = new SubType();
console.log(instance.name);//'nihao'
console.log(instance.age);//29
```

SuperType构造函数接受一个参数name,然后将它赋值给一个属性。在SubType构造函数中调用SuperType构造函数时传入这个参数，实际上是在SubType的实例上定义name属性。

为确保SuperType构造函数不会覆盖SubType定义的属性，可以在调用父类构造函数之后再给子类实例添加额外的属性。

- 盗用构造函数的问题

1.必须在构造函数中定义方法，函数不能重用。

2.子类不能访问父类原型对象上定义的方法。



#### 组合继承(伪经典继承)

组合继承综合了原型链和盗用构造函数，将两者的优点集中了起来。

基本思路是使用原型链继承原型上的属性和方法，通过盗用构造函数继承实例属性。

```javascript
function SuperType(name){
  this.name = name;
  this.colors = ['red','blue','green'];
}
SuperType.prototype.sayName = function(){
  console.log(this.name);
}
function SubType(name,age){
  SuperType.call(this,name);
  this.age = age;
}
SubType.prototype = new SuperType();
SubType.prototype.sayAge = function(){
  console.log(this.age);
}

let instance1 = new SubType('nihao',29);
instance1.colors.push('black');
console.log(instance1.colors);//['red','blue','green','black']
instance1.sayName();//'nihao'
instance1.sayAge();//29

let instance2 = new SubType('wohao',28);
console.log(instance1.colors);//['red','blue','green']
instance1.sayName();//'wohao'
instance1.sayAge();//28
```

组合继承弥补了原型链和盗用构造函数的不足，是js中使用最多的继承模式。组合继承也保留了instanceof操作符合isPrototypeOf()方法识别合成对象的能力。



#### 原型式继承

ES5通过Object.create()方法将原型式继承的概念规范化了，这个方法接收两个参数，作为新对象原型的对象，以及给新对象定义额外属性的对象。

```javascript
let person = {
  name:'wpf',
  friends:['aa','bb']
}
let otherPerson = Object.create(person,{
  name:{
    value:'huanhuan'
  }
});
otherPerson.friends.push("dd");
console.log(person.friends);//['aa','bb','dd']

```

原型式集成非常适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合。但要记住 ，属性中包含的引用值始终会在相关对象间共享，跟使用原型模式一样。



#### 寄生式继承

寄生式继承背后的思路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。

```javascript
function createAnother(original){
  let clone = object(original);
  clone.sayHi = function(){
    console.log('hi');
  }
  return clone;
}
```

createAnother()函数接收一个参数，就是新对象的基准对象。

```js
let person = {
	name: 'nicholas',
  friends:['aa','bb']
}
let anotherPerson = createAnother(person);
anotherPerson.sayHi();//hi
```

> 注意：通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似



#### 寄生式组合继承

组合继承存在效率问题：父类的构造函数始终会被调用两次，一次是在创建子类原型对象时调用，另一次是在子类构造函数中调用。

本质上，子类原型最终是要包含超类对象的所有实例属性，子类构造函数只要在执行时重写自己的原型就行了。

寄生式组合继承通过盗用构造函数继承属性，但是用混合式原型链继承方法。

基本思路是取得父类原型的一个副本。寄生式组合继承的基本模式如下：

```js
function inheritPrototype(subType,superType){
  let prototype = object(superType.prototype);//创建对象
  prototype.constructor = subType;
  subType.prototype = prototype;
}
```

这个inheritPrototype()函数实现了寄生式组合继承的核心逻辑。

这个函数接收两个参数：子类构造函数和父类构造函数。在这个函数内部，第一步是创建父类原型对象的副本，然后将副本的constructor指向子类构造函数，解决了由于重写原型导致默认constructor丢失的问题。最后将副本对象赋值给子类型的原型。

```js
function SuperType(name){
  this.name = name;
  this.colors = ['red','blue'];
}
SuperType.prototype.sayName = function(){
  console.log(this.name);
}
function SubType(name,age){
	SuperType.call(this,name);
  this.age = age;
}
inheritPrototype(SubType,SuperType);
SubType.prototype.sayAge = function(){
  console.log(this.age);
}
```

这里只调用了一次SuperType构造函数，避免了SubType.prototype上不必要也用不到的属性，而且原型链仍然保持不变，instanceof操作符和isPrototypeOf（）方法正常有效。

寄生式组合继承可以算是引用类型继承的最佳模式。



